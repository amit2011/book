\chapter{How to Write Your Own Modules and Contribute Them to MATSim \who{Zilske}}
\label{ch:extensionpoints}
% ##################################################################################################################
\hfill \textbf{Authors:} Michael Zilske

\begin{center} \includegraphics[width=0.25\textwidth, angle=0]{figures/MATSimBook.png} \end{center}

% ##################################################################################################################


% ##################################################################################################################
\section{MATSim Extension Points}
This section describes what could be called the service provider interface (SPI) of MATSim.
Historically, the main entry-point for writing a MATSim extension has been to literally extend (in the Java sense)
the Controler class. This is now discouraged. While this pattern worked when a each member of the team
was working on extending the MATSim core by a different aspect, it fails when it comes to
integrating those aspects to a single product: There is nothing one can do with a PublicTransportControler, an EmissionsControler, a RoadPricingControler and an OTFVisControler,
if what one wants is to visualize the emissions of buses on toll roads.

% =========================================================================================
\subsection{Config Group}
\label{sec:config}

% =========================================================================================
\subsection{ScenarioElement}

\subsection{Controler}
\label{sec:controlerextension}
%http://ci.matsim.org:8080/job/MATSim_M2/javadoc/org/matsim/core/controler/package-summary.html
Controler remains the main user-facing class of MATSim, but please do not subclass it. Rather,
use its setter methods to plug in your own code.

% =========================================================================================
\subsection{ControlerListener}

ControlerListeners are called at the transitions of the washing-machine diagram, in undefined order.
Thus, AControlerListener may only rely on the computation of BControlerListener if BControlerListener
 makes that computation in an earlier transition. For instance, if BControlerListener is a StartupListener
 and loads data into a Map on start-up, AControlerListener can be an IterationStartsListener and use that Map.
 But do not write two IterationStartsListeners where the first puts some data into a Map and the second expects
 to find it there - they may be called in any order.

% =========================================================================================
\subsection{Events}
\label{sec:events}
\subsubsection{What they are}
The mobility simulation moves the agents around in the virtual world according to their plans and within the bounds of the ``simulated reality''. The mobility simulation documents its moves with so-called ``Events''. These events are small pieces of information describing the action of an object at a specific time. Examples of such events can be:

    An agent finishes an activity
    An agent starts a trip
    A vehicle enters a road segment
    A vehicle leaves a road segment
    An agent boards a public transport vehicle
    An agent arrives at a location
    An agent starts an activity

Each event has a timestamp, a type, and additional attributes required to describe the action like the agent's id, a link id, an activity type or other data. In theory, it should be possible to replay the mobility simulation just by the information stored in the events. While plans describe the agents' plan for a day, the events describe how the agents' day actually was (according to the simulation).

As the events are so basic, each agent typically generates hundreds of events during one execution of a mobility simulation. In total, the number of events generated by a mobility simulation can easily reach a million or more, with large simulations even generating more than a billion events. But as the events really describe all the details from the execution of the plans, it is possible to extract mostly any kind of aggregated data one is interested in. Practically all analyses of MATSim simulations make use of events to calculate some data. Examples of such analyses are the average duration of an activity, average trip duration or distance, mode shares per time window, number of passengers in specific transit lines and many more.

The scoring of the executed plans makes use of events to find out how much time agents spent at activities or for traveling. Some replanning modules might make use of events as well: The router for example can use the information contained in events to figure out what links are jammed at certain times and route agents around that jam when creating new plans.
``

\subsubsection{How to handle them}
MATSim extensions can watch the mobility simulation by interpreting the stream of Events. This is done
by implementing an EventHandler interface and registering the implementation with the framework. The lifecycle of
an EventHandler can be chosen by the developer. Normally, an EventHandler lives as long as the simulation run.
It is notified before the beginning of each new iteration so that its state can be reset to listen to a new
iteration. This pattern can be used to collect information over all iterations. But if the purpose of
an EventHandler is used to make a calculation based on one single iteration, it may be more natural
to create a new EventHandler instance for each iteration, querying it for its result and discarding it
after the iteration finishes. This can be done in a ControlerListener.
% =========================================================================================
\subsection{PlanStrategy}

% =========================================================================================
\subsection{Scoring}
By default, MATSim uses the Charypar-Nagel utility formulation to score plans. Its parameters
are configurable.
The code which maps a stream of mobility simulation events to a score for each agent is placed behind a factory
 interface and replaceable. However, replacing it means replacing the entire utility formulation. There is
 currently no mechanism for composing a utility formulation from contributions by different modules.
 For instance, a module which simulates weather conditions would probably calculate penalties for pedestrians
  walking in heavy rain, and the Cadyts calibration scheme already uses utility offsets in its formulation. A modeller
  who wishes to compose a scoring function from the Charypar-Nagel utility, the rain penalty and the calibration offset
  needs to do this manually, in code, accessing the code of all three modules contributing to the score and (for instance) summing
  up their contributions.

As of the writing of this chapter, this makes scoring in a way the least modular part of MATSim.


% ##################################################################################################################
\section{Contributing to MATSim ... Technically}
% =========================================================================================
\subsection{Getting an Building the Source Code}
http://matsim.org/docs/devguide/development-environment

% =========================================================================================
% ##################################################################################################################
