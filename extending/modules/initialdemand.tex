% ####################################################################################################
\section{Generation of the Initial MATSim Input}
\label{sec:extending:initial-input}

As explained in Section~\ref{sec:buildingbasicscenario}, the minimal \gls{matsim} input, besides the configuration, consists of the network and the population with initial plans.  For illustrative scenarios, all three can be generated with a text editor.  For more complicated and/or realistic scenarios, they need to be generated by other methods.  People with knowledge in a scripting language may use that scripting language to generate the necessary \gls{xml} files, possibly honoring the \gls{matsim} \glspl{dtd}.  We ourselves use \gls{java} as our scripting language for these purposes.  \gls{java} is not necessarily the best choice here; this may be discussed elsewhere.  We use it anyways, for the following reasons:
\begin{itemize}

\item Most of us also program \gls{matsim} extensions, and these currently have to be in \gls{java}.  Thus, using \gls{java} as a scripting language for initial input generation saves us the effort of becoming proficient in another programming language.

\item The \gls{matsim} software, by necessity, already contains all the file readers and writers for \gls{matsim} input.  In consequence, one saves the effort of re-implementing them, and one automatically moves forward with file version updates.  Additionally, one can directly use the \gls{matsim} data containers.

\item Once one starts writing \gls{matsim} scripts-in-\gls{java} (Section~\ref{sec:writing-scripts-java}), in many situations it makes sense to modify the input data after reading the files.  The programming techniques for this are the same as for other initial input generation.

\end{itemize}
%% Section~\ref{sec:buildingbasicscenario} introduced the elements
%% required for a basic \gls{matsim} scenario.  
Part~IV will show how initial input was generated on a practical level---discussing, \eg the different types of original input data---for different scenarios.  This section  presents \gls{matsim}'s technical tools for initial input generation.
%
%% Different from the single modules' description of the previous sections of this chapter, here, functionality is achieved by combining different modules. 
%
%% Entry point are following parsimonious example scripts, which can be adapted to generate the initial demand for a specific geographical region. The scripts can be found in package \lstinline|tutorial.programming.example08DemandGeneration|; alternatively, see \url{http://matsim.org/javadoc} $\to$ main distribution.
%% Starting with version 0.7.x, the scripts are in the tutorial section of the repository, and can be found at \url{http://matsim.org/javadoc} $\to$ main distribution.

\subsection{Coordinate systems}

\todokai{overlap with Section~\ref{sec:coordinatesystems}}

Before building a \gls{matsim} scenario, one must decide on the coordinate system that one wants to use (also see Section~\ref{sec:coordinatesystems}).  The coordinate system should be metric since \gls{matsim} uses the coordinate system for distance estimates.\footnote{%
%
\gls{matsim} normally also works with non-metric coordinate systems, but some computations become a lot slower, and visualisations typically look awkward.
%
} A good choice are the \gls{utm} coordinate systems, see \url{https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system} for more information.  A typical coordinate conversion string in the \gls{java} scripts looks like
\begin{lstlisting}
CoordinateTransformation ct = \
TransformationFactory.getCoordinateTransformation("WGS84", "WGS84_UTM33N");
\end{lstlisting}
which would transform data given in WGS84 coordinates to data given in UTM coordinates.

While WGS84 is a globally valid coordinate system, UTM coordinates are only locally valid.  This has to do with the fact that the earth is approximately a sphere.  While WGS84 is a globally valid spherical coordinate system, UTM is an approximately metric projection.  Clearly, this projection is only valid at its origin, and leads to ever larger errors the further one moves away from that origin.  In consequence, each scenario needs to select its own appropriate UTM zone.

\subsection{Network Generation}

\subsubsection{From OpenStreetMap}
\label{sec:network-from-osm}

A fairly standardized way to generate a \gls{matsim} network is from \gls{osm} data.  The process roughly goes as follows:
\begin{enumerate}

\item Download the necessary \lstinline{xxx.osm.pbf} file from \url{http://download.geofabrik.de/osm}.

\item Download a recent \gls{osmosis} build from \url{http://wiki.openstreetmap.org/wiki/Osmosis}.

\item The necessary command approximately is
\begin{lstlisting}
java -cp osmosis.jar --rb file=xxx.osm.pbf \
--bounding-box top=47.701 left=8.346 bottom=47.146 right=9.019 \
completeWays=true --used-node --wb allroads.osm.pbf
\end{lstlisting}
The bounding box can, \eg be obtained from \url{http://www.osm.org}; it is in WGS84 coordinates.

\item It makes a lot of sense to add the large roads of a much larger region.  The necessary command approximately is
\begin{lstlisting}
java -cp osmosis.jar --rb file=xxx.osm.pbf --tf accept-ways \
highway=motorway,motorway_link,trunk,trunk_link,primary,primary_link \ 
--used-node --wb bigroads.osm.pbf
\end{lstlisting}

\item The two files are merged with approximately the following command:
\begin{lstlisting}
java -cp osmosis.jar --rb file=bigroads.osm.pbf --rb allroads.osm.pbf \
--merge --wx merged-network.osm
\end{lstlisting}

\end{enumerate}
An example script of how to convert the resulting \lstinline{merged-network.osm} file into a \gls{matsim} network file can be found under \url{http://matsim.org/javadoc} $\to$ main distribution $\to$ \lstinline{RunPNetworkGenerator} class.

\subsubsection{From Other Sources}

Networks can also be obtained from other sources.  An example script of how to convert an \gls{emme} network to \gls{matsim} can be found under \url{http://matsim.org/javadoc} $\to$ main distribution $\to$ \lstinline{RunNetworkEmme2MatsimExample} class.  A problem with \gls{emme} network files is that they use user-defined variables in non-standardized ways.  In consequence, each converter has to be adapted to the specific situation.

Material to read \gls{visum} files can be found by searching for the string ``visum'' in the code base, but is currently not systematically maintained.



\subsection{Initial Demand Generation}
\label{sec:extending-initial-demand}

\subsubsection{Simple Initial Demand}

A simple script to generate a population with a single synthetic person with one initial plan can be found under \url{http://matsim.org/javadoc} $\to$ main distribution $\to$ \lstinline{RunPOnePersonPopulationGenerator}.   A somewhat larger synthetic population is generated by \lstinline{RunPPopulationGenerator}.

Note that the coordinates in the population need to be consistent with the coordinates in the network.  Roughly speaking, coordinates mentioned in the population file need to be in the same range as coordinates mentioned in the network.  Note that in the examples presented here, the coordinates of the network generated in Section~\ref{sec:network-from-osm} are \emph{not} consistent with the demand generated by the \lstinline{RunP*}-scripts; these need to be adapted accordingly.

\subsubsection{Realistic Initial Demand}

A script to illustrate the generation of a more realistic population and initial demand can be found under \url{http://matsim.org/javadoc} $\to$ main distribution $\to$ \lstinline{RunZPopulationGenerator}, generating a sample population from a census file and writing it to a file.

Here, the coordinates of the network generated in Section~\ref{sec:network-from-osm} \emph{are} consistent with the demand generated by the \lstinline{RunZ*}-script.

%% \kai{folgendes ist irgendwie immer noch unsortiert.  Vielleicht besser irgendwo anders beschreiben?}

% Habe folgendes jetzt gelöscht.  Denke, eine Doku davon müsste im code javadoc starten; das hätte den Vorteil, dass es dann noch reorganisiert werden könnte.  Erst wenn es nicht mehr weiter reorganisiert wird, könnte es ins Buch.  Kai, aug'15

%% These ``scripts'' build on utility classes such as \lstinline|class PopulationUtils| providing factory functionality 
%% %by public and static methods 
%% %Im Java-Sinne sind die m.E. nicht statcs, aber eigentlich tut es auch nichts zur Sache. kai, apr'15
%% to create and manipulate elements of the module containing respective utility class. \lstinline|PopulationUtils| for example has a \lstinline|createPopulation(...)| method.

%% Utility classes are usually named \lstinline|*Utils|. 
%% Following utils exist
%% \lstinline|ConfigUtils|,
%% \lstinline|NetworkUtils|,
%% \lstinline|PopulationUtils|,
%% \lstinline|ScenarioUtils|,
%% \lstinline|ControlerUtils|,
%% \lstinline|FacilitiesUtils|,
%% \lstinline|VehicleUtils|,
%% %
%% \lstinline|EventsUtils|,
%% \lstinline|CharyparNagelScoringUtils|,
%% \lstinline|LanesUtils|,
%% \lstinline|QSimUtils|,
%% %
%% \lstinline|SignalUtils|,
%% \lstinline|TripStructureUtils|,
%% (\lstinline|ObjectAttributesUtils|), and
%% (\lstinline|VectorUtils|).
%% Furthermore, there are geometry factories contained in package \lstinline|geometry|, such as \lstinline|kaitodo|.

%%\TransformationFactory{we need something about how to use extensions}
% this is in ``Using One or More Contribs''. kai, jul'15

% ####################################################################################################
%\subsubsection{Utils}
%\ah{
%This is maybe better somewhere in Chapter~\ref{ch:extensionpoints}.
%They are not really extension points but something similar helpful for scripting.
%}
%%
%\kai{I would (strongly) vote for Chapter~\ref{ch:extensionpoints}.  ``writing scripts in java'' is a forward reference, and details should go to where it points to.  It is indeed not an ``extension point'', but something like an ``extension programming survival tool''.}

%\ah{moved this up}

% ----------------------------------------------------------------

%\kai{
%Hallo Andreas,
 %
 %Haben wir irgendwo im Buch etwas ueber ``initial input generation'' (also network.xml und plans.xml)?
 %
 %Ich finde etwas in 2.2, aber das war es dann auch.
 %
 %Irgendwie finde ich aber doch, dass wir wenigstens minimale Hinweise auf
 %
 %RunPNetworkGenerator
 %RunPOnePersonPopulationGenerator
 %
 %geben sollten.
 %
 %M.E. sind das auch ``scripts-in-java'', und damit auch Kap.32.
 %
 %Das waere dann m.E. noch vor 32.2.1, also neu
 %
 %32.2.1 initial demand generation
 %
 %32.2.2 config group
 %
 %Oder?
 %
 %VG Kai
%}
%
%\ah{Stimmt. Ich hatte frueher auch mal Kirills Popgen auf dem Schirm, dann aber Initial Demand Generation irgendwie etwas verdraengt, weil es inhaltlich durch die Szenarien abgedeckt ist. Technisch aber natuerlich nicht, werde mich die naechsten Tage daran versuchen.
%}
%
%\kai{
%Danke.  M.E. kann das eher kurz sein, mit Verweis auf die Beispiele.
%
%Ist aber der Ort, wo (m.E.) die Factories erklaert werden muessen.
%
%VG
%
%Kai
%}

% Local Variables:
% mode: latex
% mode: reftex
% mode: visual-line
% TeX-master: "../../main"
% comment-padding: 1
% fill-column: 9999
% End: 
