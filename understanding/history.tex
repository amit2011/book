\chapter{Some History of MATSim}
\label{ch:history}
% ##################################################################################################################

\hfill \textbf{Authors:} Kai Nagel, Kay W.\ Axhausen

%\begin{center} \includegraphics[width=0.3\textwidth, angle=0]{frontmatter/figures/MATSimBook} \end{center}

% ##################################################################################################################
%\kai{Auch dieses Module nur ein Vorschlag.  Ich nehme es erstmal als Ablage für Absätze, die ich in diese Richtung geschrieben habe.  Johan war daran mal sehr interessiert.}
%
%\ah{Finde es je länger desto besser dieses Kapitel drinzuhaben und es hier drinzuhaben. Wenn wir schon über die verweneten Konzepte refektieren, dann ist auch eine Art Reflektion über das MATSim-Unternehmen an sich nötig. ... wo auch die frühere History-Einsprengsel nochmals auf einen Blick und im Fluss vorkommen}
%
%\kai{Finde ich eigentlich auch.  Nehme das mal zum Anlass, da etwas mehr zu schreiben.}

\ah{Wo wir sonst noch History drinhaben und Konsistenz garantieren müssen: Editor's Foreword, Preface, Section\ref{sec:howitstarted}, Chapter~\ref{ch:developmentprocess}}

% ##################################################################################################################
\section{Scientific lineage of \gls{matsim}}
%% \section{Outside View}
\kai{``outside'' vs.\ ``inside'' view entspricht irgendwie nicht meiner Intuition.  Im Moment ist dies hier eher eine ``wissenschaftliche Herkunft'' (scientific lineage), während der nächste Teil eher meine eigene Historie darstellt.}
\label{sec:streams}
As sketched earlier \kai{wo?  Das ist doch jetzt weg, oder?}, \gls{matsim} derives from the following research streams:

% ............................................
\paragraph{Microscopic Modeling of Traffic} 
Microscopic modeling had been the basis of traffic flow simulation from the start in the 1970’s \citep[e.g.,][]{Wiedemann_PhDThesis_1974, Seddon_Simulation_1972}, but the work on traffic flow limited itself to individual links or small sequences of links and could therefore not address equilibrium as the aggregate assignment models could do from the 1970’s onward \citep[see][]{OrtuzarWillumsen_2011}. The expansion to whole and large networks came with the increasingly more powerful computers in the 1980’s and fast and still accurate enough flow models \citep[e.g.,][]{Schwerdtfeger_VolmulerHamerslag_1984, NagelSchreckenberg1992CA, Daganzo_TransResPartB_1994,Gawron_IJMPC_1998}.
%% , but these 
%% %agent-based 
%% microscopic simulations were not used to find an \gls{equilibrium} at first. 

% ............................................
\paragraph{Computational Physics} 

For \gls{matsim}, this development was helped by insights from Computational Physics, which often adopts simple and thereby very fast models of physical processes and has thus performed simulations with $10^8$ and more particles since the 1980s \citep[for a contemporary review see][]{BeazleyEtcMolec-dyn}.
%% \gls{matsim}'s microscopic modeling of traffic as well as of demand, with $10^7$ or more ``particles'', brings it into this field of many-particle systems. %\ah{numerical analysis}
It was thus clear from the beginning that urban or regional systems with $10^7$ or $10^8$ particles could be simulated microscopically; the research thus could focus on the question along which lines the necessary compromises would have to be made.

% ............................................
\paragraph{Microscopic Behavioral Modeling of Demand/Agent-Based Modeling} 
%% \kai{Habe im folgenden das mit "agent-based" expliziter diskutiert.  Pls chk.}
According to \citet[][p.~53]{RusselNorvig2010ArtificialIntelligence}, an \gls{agent} is ``anything that can be viewed as perceiving its environment through sensors and acting upon that environment through actuators''. In that sense, both the models of \citet{Seddon_Simulation_1972} and of \citet{Wiedemann_PhDThesis_1974} can be classified as agent-based, and this holds even for the simple cellular automata models of \citet{NagelSchreckenberg1992CA} since here the driver-vehicle units perceive the distance to the vehicle ahead, and act by adjusting their velocity.  
% Bei Schwerdtfeger oder Daganzo würde ich das NICHT mehr sehen, hier kommt die Geschwindigkeit nämlich aus einer Dichte, und das ist eine aggregierte Systemgröße und keine agenten-spezifische Perzeption mehr. kai, dec'14

Agent-based behavior can also be found at the level of demand modeling, where aggregate models such as the gravity model \citep{Wilson1971SpatialInteraction} can be replaced by person-centric formulations. In that sense, agent-based modeling of travel demand had been developed in Germany since the 1970s \citep[see the references in][]{AxhausenHerz_JTE_1989}, but then also in English speaking countries after the seminal book of \citet[][]{JonesEtAl_1983}.  
%% \kai{Da steht ``then'', aber das Datum bei Jones ist deutlich früher. ??}  
%% %
%% \kwaah{Axhausen und Herz fassen Arbeiten seit den 1970iger Jahren zusammen. 
%
%% Die englisch-sprachigen Kollegen beginnen erst in den 80iger Jahren. 
%% }
%
While the anglophone authors focused on sample enumeration methods to estimate the total demand with their 
%agent-based 
activity-based demand models (see \citet[][]{BradleyBowman_TRBTDF_2006} for the North American, mostly discrete choice model based, developments, and \citet[][]{ArentzeTimmermans_2000} for an alternative Dutch approach), the simpler German approach was linked with an integral mesoscopic traffic flow simulation in \citet[][]{Axhausen_PhDThesis_1988}, but not used for equilibrium search. It had, however, already a simple description of the total utility of the daily schedule.

%% \kai{according to Russel and Norvig, an agent is ``something that perceives and acts''.  Ich würde insbesondere ``perception'' bei fast allen der Arbeiten oben bezweifeln.  Außer vielleicht bei Wiedemann, aber dort richtet sich die Perzeption auch auf einen anderen Aspekt (nämlich driving). Darf ich durch die Absätze nochmal durchgehen und sie etwas abschwächen/differenzieren?}

%% \ah{gerne}

%% \kwaah{"perceives and acts" ist natuerlich eine Frage des Anspruchs an das Modell der Wahrnehmung. 

%% ORIENT/RV liess die Agenten within-trip umplanen, wenn sie laenger als erwartete Fahrtzeiten hatten; alle 
%% Verkehrsflussmodelle reagieren auf die lokale Umwelt. Auch Zumkeller’s MOBITOPP laesst die Agenten
%% reagieren. 

%% Ich wuerde bei dem Begriff bleiben.
%% }

% ............................................
\paragraph{Complex Adaptive Systems/Co-Evolutionary Algorithms}
Nash-equilibrium-like approaches had been developed in transport assignment since the seminal \citet[][]{Wardrop_PICE_1952} paper. These aggregate flow based approaches were expanded to account for perception errors of the user and for the social optimum \citep[see][]{DaganzoSheffi_TransScience_1977}.
%
\kwaah{In the late 1990's transport science addressed the process of learning in the context of the new possibilities of 'intelligent transport systems'. It used various smoothing techniques to integrate data from iteration to iteration reflecting the tradition of the field. See 

Chang, G.-L. and Mahmassani, H. S. (1989) The Dynamics of Commuting Decision Behaviour in Urban Transportation Networks, in Bernard G. (ed.), 15–26. 

\citet{KaufmanEtc-91}

Hatcher, S. G. and Mahmassani, H. S. (1992) Daily Variability of Route and Trip Scheduling Decisions for the Evening Commute, Transportation Research Record 1357, 72–81. 

Mahmassani, H. S. and Liu, Y.-H. (1999) Dynamics of Commuting Decision Behaviour under Advanced Traveller Information Systems, Transportation Research Part C: Emerging Technologies 7: 2–3, 91–107.

Polak, J.W. and F. Oladeine (2002) An empirical model of travellers' day-to-day learning in the presence of uncertain travel times, Working paper, Centre for Transport Studies, Imperial College, London.

\citet[][]{ArentzeTimmermans_TransResB_2004}

Axhausen, K.W., I. Dimitropoulos and E. Dimitrakopolou (1995) Adapting to change: some evidence from a simple learning model, paper presented at the 23rd European Transport Forum, Warwick, September 1995.

\citep{Nagel1995phd,Nagel1996NRW, Gawron_IJMPC_1998}; and \gls{transims} 

\citep[][]{SmithEtc1995TRANSIMSSeattle}. 

} \kai{obige Referenzen (1) nach ivt.bib, (2) chronologisch sortieren.}
%
%% but their reformulation for disaggregate agent-based solutions had to wait until the late 1990’s with (*) 
%
These approaches translated the logic of the Nash equilibrium
%genetic \glspl{algorithm} 
into co-evolutionary search schemes, which efficiently identified the optima of each agent’s daily schedule.
%
At the end of the 1990’s \gls{matsim} merged some of these strands into a computationally efficient tool.
%% , that is increasingly used all over the world.




% ##################################################################################################################
%\section{Kai Nagel's Perspective}
\section{Stations of development}

\kai{Wäre vielleicht gut, wenn wir das hinterher zusammenführen könnten.}

% ========================================================================================================
\subsection{Fast Microscopic Modeling of Traffic Flow (University of Cologne/Los Alamos National Laboratory)}
% Dose! Auf deutsch "Dosis".  Wenn nicht gut, dann lieber ganz reformulieren.
\label{sec:history-u-of-cologne-phase}

Kai Nagel originally wanted to do his \acrshort{phd} 
% das ist ein PhD und kein ``Philosophieae Doctor''. :-) kai
in meteorology.  When the funding did not come together, he started exploring alternatives, and applied with Prof.\ A.\ Bachem at the University of Cologne for a position in insurance modeling.  He was instead offered a position in operations research, solving problems such as dynamic vehicle routing with time windows. 

Having had some training in Computational Statistical Physics, he soon became a bit skeptical if it made sense to optimize up to the last second of a closing time window while at the same time being faced with highly stochastic transport system.  He thus embarked on using his training to build a microscopic model of the transport system, in particular single-lane~\citep{NagelSchreckenberg1992CA,Nagel1999flowTheoTrr} road traffic on long links, as well as combining such links to large-scale network-based simulations where each vehicle follows its own individual route~\citep{Nagel1996NRW}, including an adaptive dynamics being influenced most heavily by \cite{ArthurBar}.  Already that paper \citep{Nagel1996NRW} describes what is still the main \gls{matsim} architecture, where agents have many different plans, they keep trying them out, and eventually settle on the best option.  In contrast to the current approach, in that paper all plans were pre-computed, \ie there was no innovation during the iterations.  This was possible because the network was much coarser than what we use today, and thus computing route plans with enough diversity was easy.

% ========================================================================================================
\subsection{TRANSIMS (Los Alamos National Laboratory/Santa Fe Institute)}
\label{sec:history-lanl-phase}
Some of the above \acrshort{phd} work was already done at Los Alamos National Laboratory (LANL).  After his \acrshort{phd}, Kai Nagel then moved fully to LANL, where he worked with the \gls{transims} \citep[e.g.,][]{SmithEtc1995TRANSIMSSeattle} team, under the leadership of Chris Barrett.
%
The \gls{transims} project inherited some of the above design, most notably the cellular automata approach to road traffic modeling, which was thus extended to multi-lane traffic \citep{NagelWolfEtAl1998TwoLaneSystematic}, to intersections \citep{NagelEtc1997flow-char}, and to massive parallel computing \citep{NagelRickert2001parallel}.

%% However, it became quickly clear that if the goal was realistic long-term traffic forecasting, demand modelling needed to correspond to what the network loading could do.  This was the time when activity-based demand modelling gained ground \citep{Axhausen1988PhD,Bowman1998PhD,KitamuraEtcSequential}, and it was thus expected that the activity-based demand would eventually come from somewhere else.  

In terms of software design, \gls{transims} was a collection of stand-alone modules, coupled by a script.  For example, the population synthesizer would generate a population file, the activity generator would take the population file as input and generate an activities file as output, etc.  Iterations were done by running 
the traffic \gls{microsimulation} (in \gls{matsim} called \gls{mobsim})
%% \ah{replace by \gls{mobsim}?}
based on plans and outputting average link travel times, and then running the router based on link travel times and outputting plans.

% ========================================================================================================
\subsection{MATSim in \protect\gls{cpp} (ETH Zurich Computer Science)}
\label{sec:history-ethz-phase}

%\ah{somehow latex on ci.matsim.org does not like gls in section titles (?). See Build \#432. I'll try to find a work-around.}
%\ah{got it: \protect\gls{...}}

Kai Nagel moved to \gls{eth} Zürich Computer Science in 1999.  Here, it turned out to be difficult to continue with \gls{transims}, in part because \gls{transims} was not under an open source license at that time, and also because \gls{transims} fell under U.S.\ technology export restrictions for some time.  As a result, \gls{matsim} was started.

\gls{matsim} had two important differences to \gls{transims} from the beginning: (1) it tried to be more ``lightweight'', \ie running much faster, in particular by using the queue model \citep{GawronPhd,Gawron1998IterativeAlgorithmto} rather than the cellular automata model for network loading; and (2) other than \gls{transims}, agent properties such as demographic data, activity patterns or routes were no longer distributed across multiple files, but contained in one hierarchical \gls{xml} file.

Another difference followed eventually, which was to go back to the approach of \citet{Nagel1996NRW}, but this time truly following \citet{ArthurBar} by giving each individual agent its own memory \citep{RaneyNagel2006traf-framework}.  After experimentation with relational databases such as MySQL \citep{mysql-wikipedia} or Oracle \citep{oracle}, it was eventually decided to implement \gls{matsim} as an object-oriented database ``in memory'', \ie by first reading in all \gls{xml} files, modifying the data in memory during the life-time of a run, and writing the data back from memory to \gls{xml} files at the end of the run.  The decision was based on the observation that the \gls{matsim} data model was described much better by \gls{xml} files, and conversion to the relational format was impractical, prone to errors, and also too slow if not kept in memory during iterations. 

\ah{And here enters the second father of MATSim the scene ...}
% ========================================================================================================
\subsection{MATSim in \protect\gls{java} (TU Berlin and ETH Zürich)}
%\subsection{MATSim in \protect\gls{java} (TU Berlin)}
\label{sec:matsim-in-java}

\ah{A few sentences about Kay W. Axhausen, the (history of the) elements brought into MATSim by him, and the history of the start of the great collabo.}

Michael Balmer wrote his dissertation about demand modeling for \gls{matsim}, \ie about the upstream process that leads to initial plans
\citep{Balmer2007phd}.  That project, other than the main \gls{matsim} code at that time, was written in \gls{java}.  Together with the assessment that \gls{java} would be the better language than \gls{cpp} to continue development at TU Berlin transport engineering, it was decided to use Michael Balmer's code as starting point for a \gls{java} version.  Arguments for \gls{java} included:
%
\begin{itemize}\styleItemize
\item  \gls{java} is more restrictive. For example, in \gls{java} objects are always passed by reference,\footnote{%
%
We abstract away from the notion that \gls{java} ``passes object references by value'' \citep{...}.
%
} while in \gls{cpp} one has the choice between passing a pointer, a reference, or a deep copy of the object.  Since in academic environments standards are difficult to enforce, a more restrictive language seemed (and still seems) the better choice.

\item \gls{java} runs well on many platforms.  This allowed (and still allows) us to let people work on their favorite platforms, be it \gls{linux}, \gls{windows}, or \gls{mac}.

\item There is good non-commercial support for \gls{java}, for example the \gls{eclipse} \gls{ide}.

\item The \gls{java} compiler is easier to handle.  For example, there is no extraction of header files, and the \gls{java} compiler by itself sorts out the sequence in which modules need to be compiled.

\item For our applications, \gls{java} consistently was \emph{not} slower than \gls{cpp}.  This assessment was based on several years of teaching a \gls{matsim} class at \gls{eth} Zürich, where computer science students implemented simple versions of \gls{matsim} in a programming language of their choice.  It consistently came out that while the fastest \gls{cpp} code may have been 30\,\% faster than the fastest \gls{java} code, the slowest \gls{cpp} code typically was a factor of 3\,slower than the slowest \gls{java} code. In other words, while \gls{cpp} gives more opportunities for optimization, it also gives more opportunities for very serious performance degradation.

Again, in an academic environment where much of the programming style is left to the (\acrshort{phd}) students, it seemed (and still seems) more important to avoid important performance degradations than to go for the last 30\,\%.

\kai{There is also a reference for this somewhere.}

In addition, it seems that the gap between \gls{cpp} and \gls{java} has narrowed further since then.  Important differences remain in numerical applications, in part also because \gls{cpp}, other than the \gls{java}, allows operator overloading \citep{..}.  However, the agent-based approach of \gls{matsim} means that the handling of complex objects happens much more frequently than true numerical computations.

\item One reason for using \gls{cpp} was that it could be combined with \gls{mpi}, which is a reliable message passing standard for parallel computing.  Parallel computing was necessary both for performance reasons and to be able to run simulations that needed more than about 4\,\gls{gb} of memory---the maximum that could be addressed with the 32\,bit architecture that was standard at that time.  \gls{mpi} is also available for \gls{java}, but it is much less well maintained.

With the advent of the 64\,bit architectures, the second reason for parallel computing became obsolete. In addition, Kai Nagel now being at a transport engineering department, it seemed that making conceptual progress was more important than keeping the parallel computing edge, especially since the maintenance of parallel code \emph{permanently} consumes additional resources.

With the decision to give up on parallel computing, it was no longer necessary to maintain compatibility with \gls{mpi}, and thus the move to \gls{java} was facilitated.

\end{itemize}
%
In terms of language, \gls{csharp} might have been an alternative to \gls{java}.  However, \gls{csharp} depends much more on the \gls{windows} platform, and community support is not as good as it is for \gls{java}.

Clearly, the code by Michael Balmer already had all the necessary data classes, readers and writers.  This was used as a starting point to re-implement \gls{matsim} in \gls{java}.  Nevertheless, many important elements such as the \gls{mobsim}, the events architecture, scoring, routing, and the co-evolutionary architecture, had to be re-implemented.  It took about two years from taking that decision to the first plausible run of \gls{matsim} in \gls{java}.

%% In the early days of \gls{matsim}, the code was programmed in \gls{cpp} (see Chapter~\ref{ch:history}). Later, however, the code was migrated to \gls{java}. Performance of \gls{java} and \gls{cpp} had converged to a reasonable extent, such that the much higher developer friendliness of \gls{java} could be exploited. A fast access to the program is essential for \gls{matsim} as many \gls{api}-users have their background in computer science but in fields like transport planning or social sciences. 

%% Up to 2007, when \gls{matsim} was brought to \gls{sourceforge}, \gls{matsim} was provided by a download website and \gls{svn} repository hosted on a VSP server.

%% \gls{matsim} development furthermore greatly benefits from the possibility to run large-scale scenarios. Therefore, several servers with up to 512\,\gls{gb} of \gls{ram} and 40\,\gls{cpu} cores are available.  
%
% part of that argument is included further above (from 32 to 64 bit mem architecture)


% ========================================================================================================
\subsection{Code Reorganization}
\label{sec:matsim-core-reorg}
The \gls{cpp} version of \gls{matsim} was, similar to the original \gls{transims}, a collection of stand-alone executables coupled by scripts.  For example, the router would read plans and events, and replace some of the plans by other plans with modified routes.  The program flow was organized with shell scripts and makefiles.  Later it was possible to start all modules simultaneously and they would use messages to interact \citep[also see][]{GloorNagel2005ped-att04-birkh}, but the file-based and scripted interaction always remained available.

That approach had, as a consequence, very clearly defined interfaces, \ie the files. Exchanging information that was not included in the files meant changing the readers and writers on \emph{both} sides, which was in consequence rarely done, and the stand-alone modules rather tried to live with the information they had.

When \gls{matsim} was re-implemented in \gls{java} around 2006--7, it was re-implemented as one system.  As a result, now everything could interact with everything.  For example, a router could modify the network, compute routes on the modified network, and then modify it back. Clearly, it could make an error in the process, and thus erronously modifying the network.  In this way, any module could modify any data of \gls{matsim}, greatly increasing the scope for misunderstandings and errors.

What made even more problems, however, were extensions to the program flow.  The program flow was, as it still is, organized by the \lstinline$Controler$ class.  Originally, everybody who wanted to change the program flow, in particular insert his or her own research \glspl{module}, would inherit from \lstinline$Controler$, override some methods, and insert his or how own instructions.  This did, however, have the consequence that it was impossible to combine the \glspl{extension} without possibly massive manual interventions, illustrated as follows.
% (see Figure~\ref{fig:do-not-extend-controler}). \ah{reasons for this being a figure?}

%\begin{figure}\footnotesize
%\hrule
%\strut For example, assume the core method as
For example, assume the core program flow as
\begin{lstlisting}
class Controler {
   void run() {
      ...
      aMethod() ;
      ...
   }
   void aMethod() {
      doA() ;
      doB() ;
   }
}
\end{lstlisting}
Also assume an extension called \protect\lstinline$MyControler$
from one researcher, and another extension called \protect\lstinline$YourControler$ by another researcher:
\begin{lstlisting}
class MyControler extends Controler {
   @Override
   aMethod() {
      doA() ;
      doMyStuff() ;
      doB() ;
   }
}
\end{lstlisting}
\begin{lstlisting}
class YourControler extends Controler {
   @Override
   aMethod() {
      doA() ;
      doYourStuff() ;
      doB() ;
   }
}  
\end{lstlisting}
%
If you wanted to combine both approaches, you could neither say \protect\lstinline$YourControler extends MyControler$ nor \protect\lstinline$MyControler extends YourControler$, since either way one of the two extensions gets lost.  In this simple case, it may be possible to address the problem by manual intervention, but in more complicated situations this is no longer possible without extensive additional testing. %\strut
%\hrule
%\caption{Example why extending \lstinline|Controler| does not allow combination of extensions.}
%\label{fig:do-not-extend-controler}
%\end{figure}

Therefore, in 2008 a decision was made to make \gls{matsim} more modular.  The first step in that direction was a decision to submit the whole \gls{matsim} repository to frequent refactorings, \ie to \emph{not} leave the code alone as much as possible but rather make the community get used to frequent changes of code while maintaining functionality.  In order to facilitate that approach, the coverage by automatic regression tests on the build server was hugely increased, and all developers were encouraged to write automatic regression tests for their own code and their own projects. 

The changes since then are too numerous to be listed here.  They include, in particular, fairly restrictive data classes that are no longer extended or modified by every scientific project, and well-defined extensions points both in the iterative loop and inside the \gls{mobsim}.  Please see Chapter~\ref{ch:extensionpoints} for the currently existing extension points.

%% Since the huge refactoring greatly improving the code base structure and establishing, the \gls{matsim} project code is divided into the \emph{core} \lstinline|org.matsim| and \gls{api} packages \lstinline|org.matsim.api| and remaining packages. This refactoring was undertaken by the Berlin group starting at the end of 2007 and ended in the beginning of 2009 before the very first user meeting \ah{stimmt das so?}.

% ##################################################################################################################
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode: latex
% mode: reftex
% mode: visual-line
% TeX-master: "../main"
% comment-padding: 1
% fill-column: 9999
% End: 
